
import type { UseCase } from './types';

export const useCases: UseCase[] = [
  // A. Forecasting Use Cases
  {
    id: 'forecast_revenue',
    category: 'Forecasting',
    title: 'Forecast revenue for next 12–36 months',
    workflow: {
      step1: "First, the system figures out exactly what you're asking. You want to see how much money the company might make over the next 1 to 3 years. This is crucial for planning budgets, hiring, and big projects.",
      step2: "A hybrid approach is best here. We'll use SQL to grab all the historical sales numbers, then hand that data off to Python, which has powerful tools for predicting the future.",
      step3: "The SQL agent connects to the database and pulls a clean list of all past transactions. It gathers order dates, sales amounts, product types, and customer segments, then groups it all into a neat, month-by-month revenue summary.",
      step4: "The Python agent takes this historical data, cleans it up, and looks for patterns like busy seasons or steady growth. It then uses a suitable forecasting method to project these trends into the future, creating a range of likely revenue outcomes.",
      step5: "You get an interactive chart showing past revenue and the future forecast, a table with the exact numbers for each upcoming month, and clear notes explaining the forecast's confidence level. You can also download the data as a CSV file.",
      step6: "The system keeps an eye on new sales data as it comes in. It compares actual revenue to the forecast and alerts you if things are off track. The forecast model is automatically retrained periodically to stay accurate.",
    },
    flowchartSpec: {
      title: 'Forecast Revenue for Next 12–36 Months',
      nodes: [
        { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Clarify the business goal: predict future revenue.', detailed_explanation: "First, the system figures out exactly what you're asking. You want to see how much money the company might make over the next 1 to 3 years. This is crucial for planning budgets, hiring, and big projects." },
        { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Select the best tool: a hybrid SQL + Python approach.', detailed_explanation: "A hybrid approach is best here. We'll use SQL to grab all the historical sales numbers, then hand that data off to Python, which has powerful tools for predicting the future." },
        { id: 's3_sql', label: 'SQL Agent: Pull Historical Data', type: 'sql', short_hint: 'Gather and aggregate past sales data.', detailed_explanation: "The SQL agent connects to the database and pulls a clean list of all past transactions. It gathers order dates, sales amounts, product types, and customer segments, then groups it all into a neat, month-by-month revenue summary." },
        { id: 's4_python', label: 'Python Agent: Build Forecast', type: 'python', short_hint: 'Apply forecasting models to project revenue.', detailed_explanation: "The Python agent takes this historical data, cleans it up, and looks for patterns like busy seasons or steady growth. It then uses a suitable forecasting method to project these trends into the future, creating a range of likely revenue outcomes." },
        { id: 's5_output', label: 'Final Output: Chart & Table', type: 'output', short_hint: 'Visualize the forecast and provide data.', detailed_explanation: "You get an interactive chart showing past revenue and the future forecast, a table with the exact numbers for each upcoming month, and clear notes explaining the forecast's confidence level. You can also download the data as a CSV file." },
        { id: 's6_monitor', label: 'Continuous Learning & Monitoring', type: 'monitor', short_hint: 'Track accuracy and retrain the model.', detailed_explanation: "The system keeps an eye on new sales data as it comes in. It compares actual revenue to the forecast and alerts you if things are off track. The forecast model is automatically retrained periodically to stay accurate." },
      ],
      edges: [
        { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
      ],
      interaction_instructions: 'Click a node to reveal the detailed explanation; click again or close to collapse.',
      downloadables: ['revenue_forecast_report.pdf', 'forecast_table.csv', 'chart_revenue_forecast.png'],
    },
  },
  {
    id: 'predict_product_demand',
    category: 'Forecasting',
    title: 'Predict product demand for the next quarter',
    workflow: {
      step1: "The system understands you need to know how many units of each product you're likely to sell in the next three months. This helps with managing stock and planning production.",
      step2: "This is a perfect job for a Hybrid (SQL → Python) path. SQL will efficiently pull detailed sales history, and Python will run the predictive models needed for a granular forecast.",
      step3: "The SQL agent queries the database for product-level sales history. It extracts data on units sold per day/week, promotional periods, and seasonality, preparing a structured dataset for each key product.",
      step4: "The Python agent takes over, analyzing each product's sales patterns. It considers trends, seasonality, and the impact of past promotions to forecast demand for the upcoming quarter using appropriate time-series models.",
      step5: "The final output is a clear dashboard showing a demand forecast for each product, typically in a table and a chart. It highlights items with expected high demand or risk of stockouts and includes confidence intervals.",
      step6: "The system continuously tracks sales against the forecast. If a product is selling much faster or slower than predicted, it sends an alert so you can adjust your inventory or marketing plans. The models are regularly updated with fresh data.",
    },
    flowchartSpec: {
      title: 'Predict Product Demand for the Next Quarter',
      nodes: [
        { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Clarify goal: forecast units sold per product.', detailed_explanation: "The system understands you need to know how many units of each product you're likely to sell in the next three months. This helps with managing stock and planning production." },
        { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Select Hybrid (SQL → Python) for data and modeling.', detailed_explanation: "This is a perfect job for a Hybrid (SQL → Python) path. SQL will efficiently pull detailed sales history, and Python will run the predictive models needed for a granular forecast." },
        { id: 's3_sql', label: 'SQL Agent: Pull Sales History', type: 'sql', short_hint: 'Extract historical sales data for each product.', detailed_explanation: "The SQL agent queries the database for product-level sales history. It extracts data on units sold per day/week, promotional periods, and seasonality, preparing a structured dataset for each key product." },
        { id: 's4_python', label: 'Python Agent: Model Demand', type: 'python', short_hint: 'Use time-series models to predict future demand.', detailed_explanation: "The Python agent takes over, analyzing each product's sales patterns. It considers trends, seasonality, and the impact of past promotions to forecast demand for the upcoming quarter using appropriate time-series models." },
        { id: 's5_output', label: 'Final Output: Demand Dashboard', type: 'output', short_hint: 'Present forecasts in a table and chart format.', detailed_explanation: "The final output is a clear dashboard showing a demand forecast for each product, typically in a table and a chart. It highlights items with expected high demand or risk of stockouts and includes confidence intervals." },
        { id: 's6_monitor', label: 'Continuous Monitoring & Alerts', type: 'monitor', short_hint: 'Track actual sales vs. forecast and send alerts.', detailed_explanation: "The system continuously tracks sales against the forecast. If a product is selling much faster or slower than predicted, it sends an alert so you can adjust your inventory or marketing plans. The models are regularly updated with fresh data." },
      ],
      edges: [
        { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
      ],
      interaction_instructions: 'Click a node to reveal the detailed explanation.',
      downloadables: ['demand_forecast.csv', 'demand_charts.pdf'],
    },
  },
  {
    id: 'forecast_inventory_needs',
    category: 'Forecasting',
    title: 'Forecast inventory needs by product',
    workflow: {
      step1: "The system understands that you need to know how much stock of each product to order and when. The goal is to avoid stockouts on popular items and overstocking on slow-movers.",
      step2: "A Hybrid (SQL → Python) path is ideal. SQL will get current inventory levels and past sales data. Python will combine this with demand forecasts to create a purchasing plan.",
      step3: "The SQL Agent pulls two key pieces of information: current inventory levels for all products and their historical sales velocity. This data is prepared for the Python agent to analyze.",
      step4: "The Python agent first runs a demand forecast for each product. Then, it compares this forecast to current stock levels and lead times from suppliers to recommend specific reorder quantities and dates.",
      step5: "You get a clear, actionable 'Reorder Report' table. It lists which products to order, how many units to buy, and the suggested order date to ensure stock arrives on time. High-priority items are flagged.",
      step6: "The system monitors inventory levels and sales rates in real-time. It can send alerts if a product is selling faster than expected and is at risk of stocking out before the next scheduled order.",
    },
    flowchartSpec: {
      title: 'Forecast Inventory Needs by Product',
      nodes: [
        { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Determine what and when to reorder.', detailed_explanation: "The system understands that you need to know how much stock of each product to order and when. The goal is to avoid stockouts on popular items and overstocking on slow-movers." },
        { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid (SQL -> Python) for data and planning.', detailed_explanation: "A Hybrid (SQL → Python) path is ideal. SQL will get current inventory levels and past sales data. Python will combine this with demand forecasts to create a purchasing plan." },
        { id: 's3_sql', label: 'SQL Agent: Get Stock & Sales Data', type: 'sql', short_hint: 'Pull current inventory and sales velocity.', detailed_explanation: "The SQL Agent pulls two key pieces of information: current inventory levels for all products and their historical sales velocity. This data is prepared for the Python agent to analyze." },
        { id: 's4_python', label: 'Python Agent: Calculate Reorder Plan', type: 'python', short_hint: 'Forecast demand and recommend purchases.', detailed_explanation: "The Python agent first runs a demand forecast for each product. Then, it compares this forecast to current stock levels and lead times from suppliers to recommend specific reorder quantities and dates." },
        { id: 's5_output', label: 'Final Output: Reorder Report', type: 'output', short_hint: 'Provide a clear list of items to order.', detailed_explanation: "You get a clear, actionable 'Reorder Report' table. It lists which products to order, how many units to buy, and the suggested order date to ensure stock arrives on time. High-priority items are flagged." },
        { id: 's6_monitor', label: 'Real-time Inventory Monitoring', type: 'monitor', short_hint: 'Alert on risk of stockouts.', detailed_explanation: "The system monitors inventory levels and sales rates in real-time. It can send alerts if a product is selling faster than expected and is at risk of stocking out before the next scheduled order." },
      ],
      edges: [
        { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
      ],
      interaction_instructions: 'Click a node to see the detailed step explanation.',
      downloadables: ['reorder_report.csv', 'inventory_analysis.pdf'],
    },
  },
  {
    id: 'predict_subscription_cancellations',
    category: 'Forecasting',
    title: 'Predict subscription cancellations next month',
    workflow: {
      step1: "The system understands you want to forecast how many customers are likely to cancel their subscriptions in the upcoming month. This is key for revenue prediction and retention planning.",
      step2: "A Hybrid (SQL → Python) approach is necessary. SQL will gather customer subscription data and usage metrics. Python will build a predictive model to forecast the number of cancellations.",
      step3: "The SQL Agent queries the database to get a list of all active subscriptions, their renewal dates, plan types, and historical usage data (like logins, feature usage, etc.).",
      step4: "The Python agent analyzes this data to identify patterns that precede a cancellation. It then uses a classification model to predict the total number of customers likely to churn next month.",
      step5: "You receive a clear forecast: 'We predict between 450 and 520 subscription cancellations next month.' This is often shown on a dashboard with historical churn trends for context.",
      step6: "The system continuously monitors cancellation rates. The model is retrained regularly with new data to improve its accuracy and adapt to changing customer behavior.",
    },
    flowchartSpec: {
      title: 'Predict Subscription Cancellations Next Month',
      nodes: [
        { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Forecast the number of likely churns.', detailed_explanation: "The system understands you want to forecast how many customers are likely to cancel their subscriptions in the upcoming month. This is key for revenue prediction and retention planning." },
        { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path for data gathering and prediction.', detailed_explanation: "A Hybrid (SQL → Python) approach is necessary. SQL will gather customer subscription data and usage metrics. Python will build a predictive model to forecast the number of cancellations." },
        { id: 's3_sql', label: 'SQL Agent: Collect Subscription Data', type: 'sql', short_hint: 'Pull active subscriptions and usage metrics.', detailed_explanation: "The SQL Agent queries the database to get a list of all active subscriptions, their renewal dates, plan types, and historical usage data (like logins, feature usage, etc.)." },
        { id: 's4_python', label: 'Python Agent: Forecast Churn Volume', type: 'python', short_hint: 'Use models to predict cancellation counts.', detailed_explanation: "The Python agent analyzes this data to identify patterns that precede a cancellation. It then uses a classification model to predict the total number of customers likely to churn next month." },
        { id: 's5_output', label: 'Final Output: Churn Forecast', type: 'output', short_hint: 'Provide a clear number of expected cancellations.', detailed_explanation: "You receive a clear forecast: 'We predict between 450 and 520 subscription cancellations next month.' This is often shown on a dashboard with historical churn trends for context." },
        { id: 's6_monitor', label: 'Monitor & Retrain', type: 'monitor', short_hint: 'Track actual churn and update the model.', detailed_explanation: "The system continuously monitors cancellation rates. The model is retrained regularly with new data to improve its accuracy and adapt to changing customer behavior." },
      ],
      edges: [
        { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
      ],
      interaction_instructions: 'Click a node to see the detailed step explanation.',
      downloadables: ['churn_forecast.pdf'],
    },
  },
  {
    id: 'predict_customer_lifetime_value',
    category: 'Forecasting',
    title: 'Predict customer lifetime value',
    workflow: {
        step1: "The system understands you want to predict the total revenue a typical customer will generate throughout their entire relationship with the company. This helps in deciding marketing spend and identifying valuable customer segments.",
        step2: "A Hybrid (SQL → Python) path is the right choice. SQL will consolidate each customer's purchase history, and Python will build a predictive model to forecast their future value.",
        step3: "The SQL agent pulls comprehensive data for each customer, including their total spending to date, purchase frequency, date of first and last purchase, and the types of products they've bought.",
        step4: "The Python agent uses this historical data to build a Customer Lifetime Value (CLV) model. It calculates the expected number of future purchases and the likely average order value to estimate total future revenue per customer.",
        step5: "You get a report that segments your customer base by predicted CLV (e.g., High-Value, Medium-Value, Low-Value). It also provides an average predicted CLV for new customers, which is useful for acquisition cost analysis.",
        step6: "The system periodically re-calculates CLV as new purchase data becomes available. This ensures the customer segments remain up-to-date and reflects any changes in purchasing behavior.",
    },
    flowchartSpec: {
        title: 'Predict Customer Lifetime Value',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Predict total future revenue from a customer.', detailed_explanation: "The system understands you want to predict the total revenue a typical customer will generate throughout their entire relationship with the company. This helps in deciding marketing spend and identifying valuable customer segments." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path for historical data and predictive modeling.', detailed_explanation: "A Hybrid (SQL → Python) path is the right choice. SQL will consolidate each customer's purchase history, and Python will build a predictive model to forecast their future value." },
            { id: 's3_sql', label: 'SQL Agent: Gather Purchase History', type: 'sql', short_hint: 'Consolidate spending and frequency for each customer.', detailed_explanation: "The SQL agent pulls comprehensive data for each customer, including their total spending to date, purchase frequency, date of first and last purchase, and the types of products they've bought." },
            { id: 's4_python', label: 'Python Agent: Model Future Value', type: 'python', short_hint: 'Build a CLV model to forecast future spending.', detailed_explanation: "The Python agent uses this historical data to build a Customer Lifetime Value (CLV) model. It calculates the expected number of future purchases and the likely average order value to estimate total future revenue per customer." },
            { id: 's5_output', label: 'Final Output: CLV Segments', type: 'output', short_hint: 'Group customers by their predicted lifetime value.', detailed_explanation: "You get a report that segments your customer base by predicted CLV (e.g., High-Value, Medium-Value, Low-Value). It also provides an average predicted CLV for new customers, which is useful for acquisition cost analysis." },
            { id: 's6_monitor', label: 'Continuous Recalculation', type: 'monitor', short_hint: 'Update CLV predictions with new purchase data.', detailed_explanation: "The system periodically re-calculates CLV as new purchase data becomes available. This ensures the customer segments remain up-to-date and reflects any changes in purchasing behavior." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
        downloadables: ['clv_segments.csv', 'clv_analysis_report.pdf'],
    },
  },
  {
    id: 'predict_recovery_timeline',
    category: 'Forecasting',
    title: 'Predict recovery timeline after a sales drop',
    workflow: {
        step1: "The system understands you've experienced a sales drop and want to know how long it will take to get back to normal levels. This is for setting realistic expectations and managing resources.",
        step2: "A Hybrid (SQL → Python) path is most effective. SQL gathers data on past sales dips and recoveries, and Python uses this to model a likely timeline for the current situation.",
        step3: "The SQL agent looks for historical instances of sales drops. It pulls data on the depth and duration of those drops, and how long the subsequent recovery took, along with any actions taken (e.g., marketing campaigns).",
        step4: "The Python agent analyzes these historical recovery patterns. It compares the current drop to past events and uses a forecasting model to project a probable timeline for sales to return to the pre-drop trend.",
        step5: "You receive a chart showing the sales drop and a projected recovery curve, with an estimated date for returning to the baseline. For example: 'Sales are predicted to return to normal levels by mid-next-month.'",
        step6: "The system tracks daily sales against the predicted recovery curve. It can issue an alert if the recovery is happening faster or slower than expected, allowing you to adjust your strategy.",
    },
    flowchartSpec: {
        title: 'Predict Recovery Timeline After a Sales Drop',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Estimate time to return to normal sales levels.', detailed_explanation: "The system understands you've experienced a sales drop and want to know how long it will take to get back to normal levels. This is for setting realistic expectations and managing resources." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path to analyze historical dips and forecast.', detailed_explanation: "A Hybrid (SQL → Python) path is most effective. SQL gathers data on past sales dips and recoveries, and Python uses this to model a likely timeline for the current situation." },
            { id: 's3_sql', label: 'SQL Agent: Find Historical Dips', type: 'sql', short_hint: 'Gather data on past sales drops and recoveries.', detailed_explanation: "The SQL agent looks for historical instances of sales drops. It pulls data on the depth and duration of those drops, and how long the subsequent recovery took, along with any actions taken (e.g., marketing campaigns)." },
            { id: 's4_python', label: 'Python Agent: Model Recovery Curve', type: 'python', short_hint: 'Use historical patterns to project a timeline.', detailed_explanation: "The Python agent analyzes these historical recovery patterns. It compares the current drop to past events and uses a forecasting model to project a probable timeline for sales to return to the pre-drop trend." },
            { id: 's5_output', label: 'Final Output: Recovery Forecast', type: 'output', short_hint: 'Visualize the estimated recovery timeline.', detailed_explanation: "You receive a chart showing the sales drop and a projected recovery curve, with an estimated date for returning to the baseline. For example: 'Sales are predicted to return to normal levels by mid-next-month.'" },
            { id: 's6_monitor', label: 'Track Recovery Progress', type: 'monitor', short_hint: 'Compare actual sales to the recovery forecast.', detailed_explanation: "The system tracks daily sales against the predicted recovery curve. It can issue an alert if the recovery is happening faster or slower than expected, allowing you to adjust your strategy." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
        downloadables: ['recovery_timeline.png', 'recovery_analysis.pdf'],
    },
  },
  {
    id: 'predict_customer_churn',
    category: 'Forecasting',
    title: 'Predict customer churn',
    workflow: {
        step1: "The system understands that you want to identify which specific customers are at a high risk of churning (leaving your service or not making a repeat purchase). This allows for proactive retention efforts.",
        step2: "A Hybrid (SQL → Python) approach is best. SQL will gather behavioral data for all customers, and Python will use this data to build a model that scores each customer's churn risk.",
        step3: "The SQL agent collects a rich dataset for each active customer, including their purchase frequency, time since last purchase, customer service interactions, and product usage data.",
        step4: "The Python agent uses a machine learning classification model. It learns the patterns of customers who have churned in the past and applies this learning to score the churn probability for every current customer.",
        step5: "You receive an actionable list of customers with the highest churn risk, often with their risk score (e.g., 85% probability of churning). The list may also include the key factors contributing to their risk.",
        step6: "This churn prediction model can be run on a regular schedule (e.g., weekly). The system monitors the high-risk list and can trigger workflows, like alerting a customer success manager to reach out.",
    },
    flowchartSpec: {
        title: 'Predict Customer Churn',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Identify which customers are likely to leave.', detailed_explanation: "The system understands that you want to identify which specific customers are at a high risk of churning (leaving your service or not making a repeat purchase). This allows for proactive retention efforts." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path for data collection and risk scoring.', detailed_explanation: "A Hybrid (SQL → Python) approach is best. SQL will gather behavioral data for all customers, and Python will use this data to build a model that scores each customer's churn risk." },
            { id: 's3_sql', label: 'SQL Agent: Gather Behavioral Data', type: 'sql', short_hint: 'Collect purchase history and engagement metrics.', detailed_explanation: "The SQL agent collects a rich dataset for each active customer, including their purchase frequency, time since last purchase, customer service interactions, and product usage data." },
            { id: 's4_python', label: 'Python Agent: Score Churn Risk', type: 'python', short_hint: 'Use a model to predict churn probability per customer.', detailed_explanation: "The Python agent uses a machine learning classification model. It learns the patterns of customers who have churned in the past and applies this learning to score the churn probability for every current customer." },
            { id: 's5_output', label: 'Final Output: High-Risk Customer List', type: 'output', short_hint: 'Provide an actionable list of at-risk customers.', detailed_explanation: "You receive an actionable list of customers with the highest churn risk, often with their risk score (e.g., 85% probability of churning). The list may also include the key factors contributing to their risk." },
            { id: 's6_monitor', label: 'Continuous Risk Monitoring', type: 'monitor', short_hint: 'Regularly update churn scores and trigger alerts.', detailed_explanation: "This churn prediction model can be run on a regular schedule (e.g., weekly). The system monitors the high-risk list and can trigger workflows, like alerting a customer success manager to reach out." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
        downloadables: ['high_risk_customers.csv', 'churn_prediction_report.pdf'],
    },
  },

  // B. Diagnostic Use Cases
  {
    id: 'analyze_sales_drop',
    category: 'Diagnostic',
    title: 'Analyze root causes of a sales drop',
    workflow: {
      step1: "The system understands your immediate concern: sales have dropped, and you need to know why, fast. The goal is to pinpoint the main reasons to inform a recovery plan.",
      step2: "A Hybrid (SQL → Python) approach is best for this investigation. SQL is great for slicing and dicing the data in many ways, while Python can dig deeper to find subtle correlations and anomalies.",
      step3: "The SQL agent pulls a wide range of data from the period of the sales drop and a comparable 'normal' period. This includes sales by region, product, channel, customer segment, and any marketing or operational logs.",
      step4: "The Python agent performs a contribution analysis. It systematically compares the 'drop' period to the 'normal' period across all dimensions to see what changed the most. It might identify that a specific region underperformed, a top-selling product saw a sudden decline, or a marketing channel stopped converting.",
      step5: "You receive a clear, prioritized list of the most likely causes for the sales drop. For example: 'Sales dropped by $50k last week. 70% of this drop is attributed to a 50% decrease in conversion from the 'Paid Search' channel.' This is often paired with charts visualizing the key drivers.",
      step6: "The system can set up automated monitoring to watch for similar patterns in the future. If the key metrics that led to this drop start to decline again, it can trigger an early warning alert, allowing you to act before a major drop occurs.",
    },
    flowchartSpec: {
      title: 'Analyze Root Causes of a Sales Drop',
      nodes: [
        { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Identify the urgent need: find out why sales dropped.', detailed_explanation: "The system understands your immediate concern: sales have dropped, and you need to know why, fast. The goal is to pinpoint the main reasons to inform a recovery plan." },
        { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Select a Hybrid path for deep-dive diagnostics.', detailed_explanation: "A Hybrid (SQL → Python) approach is best for this investigation. SQL is great for slicing and dicing the data in many ways, while Python can dig deeper to find subtle correlations and anomalies." },
        { id: 's3_sql', label: 'SQL Agent: Gather Contextual Data', type: 'sql', short_hint: 'Pull sales, marketing, and operational data.', detailed_explanation: "The SQL agent pulls a wide range of data from the period of the sales drop and a comparable 'normal' period. This includes sales by region, product, channel, customer segment, and any marketing or operational logs (e.g., promotions, website downtime)." },
        { id: 's4_python', label: 'Python Agent: Contribution Analysis', type: 'python', short_hint: 'Compare periods to find the biggest drivers.', detailed_explanation: "The Python agent performs a contribution analysis. It systematically compares the 'drop' period to the 'normal' period across all dimensions to see what changed the most. It might identify that a specific region underperformed, a top-selling product saw a sudden decline, or a marketing channel stopped converting." },
        { id: 's5_output', label: 'Final Output: Prioritized Root Causes', type: 'output', short_hint: 'Deliver a clear list of what caused the drop.', detailed_explanation: "You receive a clear, prioritized list of the most likely causes for the sales drop. For example: 'Sales dropped by $50k last week. 70% of this drop is attributed to a 50% decrease in conversion from the 'Paid Search' channel.' This is often paired with charts visualizing the key drivers." },
        { id: 's6_monitor', label: 'Set Up Anomaly Monitoring', type: 'monitor', short_hint: 'Create alerts for early warnings of similar issues.', detailed_explanation: "The system can set up automated monitoring to watch for similar patterns in the future. If the key metrics that led to this drop start to decline again, it can trigger an early warning alert, allowing you to act before a major drop occurs." },
      ],
      edges: [
        { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
      ],
      interaction_instructions: 'Click a node to see the detailed step explanation.',
      downloadables: ['sales_drop_analysis.pdf', 'root_cause_data.csv'],
    },
  },
  {
    id: 'detect_sales_anomalies',
    category: 'Diagnostic',
    title: 'Detect anomalies in daily sales and explain the reasons',
    workflow: {
      step1: "The system understands that you want to be automatically notified of any unusual spikes or dips in daily sales and understand what caused them without having to look for them manually.",
      step2: "This requires a Hybrid (SQL → Python) approach. SQL will provide the daily sales data, and Python will run anomaly detection algorithms and search for contributing factors.",
      step3: "On a daily basis, the SQL agent extracts the total sales figures, as well as sales broken down by key dimensions like product category, region, and marketing channel.",
      step4: "The Python agent first uses a statistical model to determine if the day's sales are anomalous compared to historical patterns. If an anomaly is detected, it then runs a diagnostic analysis to identify the key drivers, similar to the sales drop use case.",
      step5: "If an anomaly is found, you receive an alert. For example: 'Alert: Daily sales were 35% higher than expected yesterday. This was driven by a 200% sales increase in the 'Gadgets' category, linked to the 'Summer Sale' campaign.'",
      step6: "This process runs continuously in the background. The system learns what normal sales look like over time, adjusting for seasonality and growth, making the anomaly detection increasingly accurate.",
    },
    flowchartSpec: {
      title: 'Detect Anomalies in Daily Sales and Explain Reasons',
      nodes: [
        { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Automate detection of unusual sales activity.', detailed_explanation: "The system understands that you want to be automatically notified of any unusual spikes or dips in daily sales and understand what caused them without having to look for them manually." },
        { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path for continuous data monitoring.', detailed_explanation: "This requires a Hybrid (SQL → Python) approach. SQL will provide the daily sales data, and Python will run anomaly detection algorithms and search for contributing factors." },
        { id: 's3_sql', label: 'SQL Agent: Pull Daily Sales Data', type: 'sql', short_hint: 'Extract daily sales figures by key dimensions.', detailed_explanation: "On a daily basis, the SQL agent extracts the total sales figures, as well as sales broken down by key dimensions like product category, region, and marketing channel." },
        { id: 's4_python', label: 'Python Agent: Detect & Diagnose', type: 'python', short_hint: 'Run anomaly detection and find root causes.', detailed_explanation: "The Python agent first uses a statistical model to determine if the day's sales are anomalous compared to historical patterns. If an anomaly is detected, it then runs a diagnostic analysis to identify the key drivers, similar to the sales drop use case." },
        { id: 's5_output', label: 'Final Output: Automated Alert', type: 'output', short_hint: 'Send an alert with the anomaly and its cause.', detailed_explanation: "If an anomaly is found, you receive an alert. For example: 'Alert: Daily sales were 35% higher than expected yesterday. This was driven by a 200% sales increase in the 'Gadgets' category, linked to the 'Summer Sale' campaign.'" },
        { id: 's6_monitor', label: 'Continuous Background Monitoring', type: 'monitor', short_hint: 'Continuously learn and refine the detection model.', detailed_explanation: "This process runs continuously in the background. The system learns what normal sales look like over time, adjusting for seasonality and growth, making the anomaly detection increasingly accurate." },
      ],
      edges: [
        { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
      ],
      interaction_instructions: 'Click a node to see the detailed step explanation.',
    },
  },
  {
    id: 'diagnose_conversion_drop',
    category: 'Diagnostic',
    title: 'Identify why conversion rate suddenly dropped',
    workflow: {
        step1: "The system understands the urgency: your website's or app's conversion rate has fallen, and you need to know why. The goal is to identify if it's a technical issue, a marketing change, or a shift in user behavior.",
        step2: "A Hybrid (SQL → Python) approach is best. SQL can quickly segment user sessions, while Python can analyze patterns and identify the most significant changes.",
        step3: "The SQL agent pulls web analytics data, comparing the period of the drop to a normal period. It segments sessions by traffic source, device type (desktop/mobile), browser, user location, and landing page.",
        step4: "The Python agent performs a contribution analysis on the conversion rate. It pinpoints which segment saw the biggest drop. For example, it might find that the conversion rate for mobile users on Safari browsers dropped by 80%, suggesting a technical bug.",
        step5: "You get a direct answer: 'The conversion rate drop is primarily driven by mobile users from organic search, whose conversion fell from 4% to 0.5%. This coincides with the new website release.' The output highlights the most likely cause.",
        step6: "The system can set up a continuous monitor on conversion rates for key segments. If the rate for a specific segment (like mobile users) drops below a set threshold, it automatically triggers an alert for immediate investigation.",
    },
    flowchartSpec: {
        title: 'Identify Why Conversion Rate Suddenly Dropped',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Find the cause of a lower conversion rate.', detailed_explanation: "The system understands the urgency: your website's or app's conversion rate has fallen, and you need to know why. The goal is to identify if it's a technical issue, a marketing change, or a shift in user behavior." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path to segment data and find the source.', detailed_explanation: "A Hybrid (SQL → Python) approach is best. SQL can quickly segment user sessions, while Python can analyze patterns and identify the most significant changes." },
            { id: 's3_sql', label: 'SQL Agent: Segment Session Data', type: 'sql', short_hint: 'Pull analytics data by source, device, browser, etc.', detailed_explanation: "The SQL agent pulls web analytics data, comparing the period of the drop to a normal period. It segments sessions by traffic source, device type (desktop/mobile), browser, user location, and landing page." },
            { id: 's4_python', label: 'Python Agent: Pinpoint the Drop', type: 'python', short_hint: 'Analyze which user segment is responsible.', detailed_explanation: "The Python agent performs a contribution analysis on the conversion rate. It pinpoints which segment saw the biggest drop. For example, it might find that the conversion rate for mobile users on Safari browsers dropped by 80%, suggesting a technical bug." },
            { id: 's5_output', label: 'Final Output: Diagnostic Finding', type: 'output', short_hint: 'Deliver a clear explanation of the cause.', detailed_explanation: "You get a direct answer: 'The conversion rate drop is primarily driven by mobile users from organic search, whose conversion fell from 4% to 0.5%. This coincides with the new website release.' The output highlights the most likely cause." },
            { id: 's6_monitor', label: 'Monitor Key Segments', type: 'monitor', short_hint: 'Set up alerts for future drops in conversion.', detailed_explanation: "The system can set up a continuous monitor on conversion rates for key segments. If the rate for a specific segment (like mobile users) drops below a set threshold, it automatically triggers an alert for immediate investigation." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
        downloadables: ['conversion_drop_report.pdf'],
    },
  },
  {
    id: 'investigate_refund_spike',
    category: 'Diagnostic',
    title: 'Investigate sudden spike in refunds',
    workflow: {
        step1: "The system understands a spike in refunds is a serious issue. The goal is to quickly find out if it's related to a specific product, a shipping issue, a bad product batch, or something else.",
        step2: "A Hybrid (SQL → Python) path is ideal. SQL can aggregate the refund data, and Python can look for common patterns among the refunded orders.",
        step3: "The SQL agent pulls all refund data from the spike period. It joins this with order information to get details like the product(s) refunded, the customer's location, the shipping carrier, and the delivery date.",
        step4: "The Python agent analyzes this dataset to find commonalities. It looks for a single product that appears in a high percentage of refunds, or a cluster of refunds from a specific geographic region or a particular shipping batch.",
        step5: "You get a concise summary of the findings. For example: '85% of the refunds in the last 48 hours were for 'Product X'. Customer feedback suggests a quality issue with the latest batch.'",
        step6: "The system can monitor the refund rate in near real-time. If the rate for a specific product or category exceeds a normal threshold, it can automatically flag it for review by the product and operations teams.",
    },
    flowchartSpec: {
        title: 'Investigate Sudden Spike in Refunds',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Find the cause of increased refunds.', detailed_explanation: "The system understands a spike in refunds is a serious issue. The goal is to quickly find out if it's related to a specific product, a shipping issue, a bad product batch, or something else." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path to aggregate and find patterns.', detailed_explanation: "A Hybrid (SQL → Python) path is ideal. SQL can aggregate the refund data, and Python can look for common patterns among the refunded orders." },
            { id: 's3_sql', label: 'SQL Agent: Gather Refund Data', type: 'sql', short_hint: 'Pull refund records with order details.', detailed_explanation: "The SQL agent pulls all refund data from the spike period. It joins this with order information to get details like the product(s) refunded, the customer's location, the shipping carrier, and the delivery date." },
            { id: 's4_python', label: 'Python Agent: Find Common Patterns', type: 'python', short_hint: 'Analyze refunds to find the root cause.', detailed_explanation: "The Python agent analyzes this dataset to find commonalities. It looks for a single product that appears in a high percentage of refunds, or a cluster of refunds from a specific geographic region or a particular shipping batch." },
            { id: 's5_output', label: 'Final Output: Root Cause Summary', type: 'output', short_hint: 'Deliver a clear explanation for the spike.', detailed_explanation: "You get a concise summary of the findings. For example: '85% of the refunds in the last 48 hours were for 'Product X'. Customer feedback suggests a quality issue with the latest batch.'" },
            { id: 's6_monitor', label: 'Continuous Refund Monitoring', type: 'monitor', short_hint: 'Set up alerts for future refund spikes.', detailed_explanation: "The system can monitor the refund rate in near real-time. If the rate for a specific product or category exceeds a normal threshold, it can automatically flag it for review by the product and operations teams." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
        downloadables: ['refund_spike_analysis.pdf'],
    },
  },
  {
    id: 'explain_product_stopped_selling',
    category: 'Diagnostic',
    title: 'Explain why a product/category stopped selling',
    workflow: {
        step1: "The system understands your concern: a product or an entire category that used to sell well has suddenly seen its sales drop to near zero. The goal is to figure out if this is a demand, pricing, or technical issue.",
        step2: "A Hybrid (SQL → Python) approach is best for a multi-faceted investigation. SQL will pull all relevant data about the product, and Python will look for the most likely cause.",
        step3: "The SQL agent gathers a 360-degree view of the product: its sales history, inventory levels, pricing history, website traffic to its page, and any recent changes in its description or placement on the site.",
        step4: "The Python agent acts like a detective. It checks for common culprits in order: Is it out of stock? Was there a recent price increase? Did website traffic to its page suddenly drop? Has it been removed from a key landing page? Is there a new, strong competitor?",
        step5: "You receive a direct diagnosis. For example: 'The 'Winter Coat' category stopped selling on Monday. This coincides with the launch of the new 'Spring Collection' which replaced it on the homepage.' or 'Product Y stopped selling because inventory reached zero three days ago.'",
        step6: "The system can monitor the sales velocity of top products. If a historically strong seller has zero sales for a set period (e.g., 48 hours), it can trigger an alert to the merchandising team to investigate.",
    },
    flowchartSpec: {
        title: 'Explain Why a Product/Category Stopped Selling',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Find out why a product has no sales.', detailed_explanation: "The system understands your concern: a product or an entire category that used to sell well has suddenly seen its sales drop to near zero. The goal is to figure out if this is a demand, pricing, or technical issue." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path for a comprehensive investigation.', detailed_explanation: "A Hybrid (SQL → Python) approach is best for a multi-faceted investigation. SQL will pull all relevant data about the product, and Python will look for the most likely cause." },
            { id: 's3_sql', label: 'SQL Agent: Get 360° Product View', type: 'sql', short_hint: 'Pull sales, inventory, pricing, and traffic data.', detailed_explanation: "The SQL agent gathers a 360-degree view of the product: its sales history, inventory levels, pricing history, website traffic to its page, and any recent changes in its description or placement on the site." },
            { id: 's4_python', label: 'Python Agent: Diagnostic Checklist', type: 'python', short_hint: 'Systematically check for common causes.', detailed_explanation: "The Python agent acts like a detective. It checks for common culprits in order: Is it out of stock? Was there a recent price increase? Did website traffic to its page suddenly drop? Has it been removed from a key landing page? Is there a new, strong competitor?" },
            { id: 's5_output', label: 'Final Output: Clear Diagnosis', type: 'output', short_hint: 'Provide the most likely reason for the sales stop.', detailed_explanation: "You receive a direct diagnosis. For example: 'The 'Winter Coat' category stopped selling on Monday. This coincides with the launch of the new 'Spring Collection' which replaced it on the homepage.' or 'Product Y stopped selling because inventory reached zero three days ago.'" },
            { id: 's6_monitor', label: 'Monitor Top-Seller Velocity', type: 'monitor', short_hint: 'Alert if a key product has zero sales.', detailed_explanation: "The system can monitor the sales velocity of top products. If a historically strong seller has zero sales for a set period (e.g., 48 hours), it can trigger an alert to the merchandising team to investigate." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
    },
  },
   {
    id: 'find_operational_issues',
    category: 'Diagnostic',
    title: 'Find operational issues affecting revenue',
    workflow: {
        step1: "The system understands you suspect that operational problems like website downtime, shipping delays, or stockouts are hurting sales, and you want to quantify the impact.",
        step2: "A Hybrid (SQL → Python) path is required. SQL will gather operational logs and sales data, and Python will correlate them to find links and measure the financial impact.",
        step3: "The SQL agent pulls data from multiple sources: website uptime logs, shipping carrier performance reports, and inventory records. It aligns these logs with the sales data on a timeline.",
        step4: "The Python agent looks for correlations. For example, it checks if a sales drop in a specific region coincided with shipping delays in that same region. It can also calculate the revenue lost during a period of website downtime by comparing it to a normal period.",
        step5: "You receive a report quantifying the impact of these issues. For example: 'Last month's 2-hour website outage resulted in an estimated $25,000 in lost revenue.' or 'An average 3-day shipping delay to California is correlated with a 15% drop in repeat purchases from that state.'",
        step6: "The system can create a real-time operational dashboard that monitors key metrics like site uptime, order processing times, and stock levels, and alerts the team if any metric falls below an acceptable level.",
    },
    flowchartSpec: {
        title: 'Find Operational Issues Affecting Revenue',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Quantify how operational issues impact sales.', detailed_explanation: "The system understands you suspect that operational problems like website downtime, shipping delays, or stockouts are hurting sales, and you want to quantify the impact." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path to correlate operational and sales data.', detailed_explanation: "A Hybrid (SQL → Python) path is required. SQL will gather operational logs and sales data, and Python will correlate them to find links and measure the financial impact." },
            { id: 's3_sql', label: 'SQL Agent: Gather Operational Logs', type: 'sql', short_hint: 'Pull uptime, shipping, and inventory data.', detailed_explanation: "The SQL agent pulls data from multiple sources: website uptime logs, shipping carrier performance reports, and inventory records. It aligns these logs with the sales data on a timeline." },
            { id: 's4_python', label: 'Python Agent: Correlate and Quantify', type: 'python', short_hint: 'Find links between issues and lost revenue.', detailed_explanation: "The Python agent looks for correlations. For example, it checks if a sales drop in a specific region coincided with shipping delays in that same region. It can also calculate the revenue lost during a period of website downtime by comparing it to a normal period." },
            { id: 's5_output', label: 'Final Output: Impact Report', type: 'output', short_hint: 'Deliver a report on revenue lost to operational issues.', detailed_explanation: "You receive a report quantifying the impact of these issues. For example: 'Last month's 2-hour website outage resulted in an estimated $25,000 in lost revenue.' or 'An average 3-day shipping delay to California is correlated with a 15% drop in repeat purchases from that state.'" },
            { id: 's6_monitor', label: 'Real-time Operational Dashboard', type: 'monitor', short_hint: 'Monitor key operational metrics and send alerts.', detailed_explanation: "The system can create a real-time operational dashboard that monitors key metrics like site uptime, order processing times, and stock levels, and alerts the team if any metric falls below an acceptable level." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
        downloadables: ['operational_impact_report.pdf'],
    },
  },

  // C. Simulation & Scenario Use Cases
  {
    id: 'simulate_price_increase',
    category: 'Simulation',
    title: 'Simulate how revenue changes if prices increase by 5%',
    workflow: {
        step1: "The system understands you want to explore a 'what-if' scenario: if we raise prices by 5%, what will happen to our total revenue? This involves balancing higher price-per-item against a potential drop in sales volume.",
        step2: "A Hybrid (SQL → Python) path is best. SQL will get the historical sales and pricing data. Python will model the price elasticity and simulate the outcome.",
        step3: "The SQL agent pulls historical sales data, including the number of units sold at different price points in the past (e.g., during promotions or after previous price changes).",
        step4: "The Python agent first calculates the price elasticity of demand for your products, which measures how much sales volume changes when the price changes. It then uses this elasticity to simulate the effect of a 5% price increase, projecting the new sales volume and calculating the total revenue.",
        step5: "You receive a clear simulation result: 'A 5% price increase is projected to decrease sales volume by 3%, but increase total revenue by approximately 1.8%. The projected monthly revenue is $509,000.'",
        step6: "If you proceed with the price change, the system can monitor the actual sales and revenue impact. It will compare the real-world results to the simulation's prediction and refine the elasticity model for future simulations.",
    },
    flowchartSpec: {
        title: 'Simulate How Revenue Changes if Prices Increase by 5%',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Model the revenue impact of a price increase.', detailed_explanation: "The system understands you want to explore a 'what-if' scenario: if we raise prices by 5%, what will happen to our total revenue? This involves balancing higher price-per-item against a potential drop in sales volume." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path to model elasticity and simulate.', detailed_explanation: "A Hybrid (SQL → Python) path is best. SQL will get the historical sales and pricing data. Python will model the price elasticity and simulate the outcome." },
            { id: 's3_sql', label: 'SQL Agent: Get Historical Price Data', type: 'sql', short_hint: 'Pull units sold at various past price points.', detailed_explanation: "The SQL agent pulls historical sales data, including the number of units sold at different price points in the past (e.g., during promotions or after previous price changes)." },
            { id: 's4_python', label: 'Python Agent: Model Elasticity & Simulate', type: 'python', short_hint: 'Calculate price elasticity and project new revenue.', detailed_explanation: "The Python agent first calculates the price elasticity of demand for your products, which measures how much sales volume changes when the price changes. It then uses this elasticity to simulate the effect of a 5% price increase, projecting the new sales volume and calculating the total revenue." },
            { id: 's5_output', label: 'Final Output: Simulation Result', type: 'output', short_hint: 'Provide a clear projection of the revenue impact.', detailed_explanation: "You receive a clear simulation result: 'A 5% price increase is projected to decrease sales volume by 3%, but increase total revenue by approximately 1.8%. The projected monthly revenue is $509,000.'" },
            { id: 's6_monitor', label: 'Monitor & Refine Model', type: 'monitor', short_hint: 'Track actual results and improve the elasticity model.', detailed_explanation: "If you proceed with the price change, the system can monitor the actual sales and revenue impact. It will compare the real-world results to the simulation's prediction and refine the elasticity model for future simulations." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
        downloadables: ['price_simulation_report.pdf'],
    },
  },
   {
    id: 'simulate_discount_reduction',
    category: 'Simulation',
    title: 'Simulate effect of reducing discounts by 10%',
    workflow: {
        step1: "The system understands you want to know what would happen to sales and profit margins if you reduced the average discount offered by 10%. The goal is to see if the higher margin outweighs any potential drop in sales.",
        step2: "A Hybrid (SQL → Python) path is perfect. SQL will pull data on sales made with and without discounts. Python will model the impact of the change.",
        step3: "The SQL agent gathers historical transaction data, specifically noting which sales involved a discount, the discount percentage, and the product's profit margin.",
        step4: "The Python agent analyzes the 'lift' that discounts provide to sales volume. It then simulates a scenario where all discounts are reduced by 10%, projecting the new, lower sales volume but the higher profit per sale. It calculates the net effect on total profit.",
        step5: "You get a clear summary of the trade-off. For example: 'Reducing discounts by 10% is projected to decrease sales volume by 4%, but increase gross profit by $15,000 per month due to higher margins.'",
        step6: "If the discount change is implemented, the system can track the actual impact on both sales volume and profit margins, comparing it against the simulation's predictions to refine future analyses.",
    },
    flowchartSpec: {
        title: 'Simulate Effect of Reducing Discounts by 10%',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Analyze the profit impact of smaller discounts.', detailed_explanation: "The system understands you want to know what would happen to sales and profit margins if you reduced the average discount offered by 10%. The goal is to see if the higher margin outweighs any potential drop in sales." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path for modeling sales lift vs. margin.', detailed_explanation: "A Hybrid (SQL → Python) path is perfect. SQL will pull data on sales made with and without discounts. Python will model the impact of the change." },
            { id: 's3_sql', label: 'SQL Agent: Get Discount Data', type: 'sql', short_hint: 'Pull historical sales data with discount levels.', detailed_explanation: "The SQL agent gathers historical transaction data, specifically noting which sales involved a discount, the discount percentage, and the product's profit margin." },
            { id: 's4_python', label: 'Python Agent: Simulate Profit Impact', type: 'python', short_hint: 'Model the trade-off between volume and margin.', detailed_explanation: "The Python agent analyzes the 'lift' that discounts provide to sales volume. It then simulates a scenario where all discounts are reduced by 10%, projecting the new, lower sales volume but the higher profit per sale. It calculates the net effect on total profit." },
            { id: 's5_output', label: 'Final Output: Simulation Summary', type: 'output', short_hint: 'Provide a clear projection of the net profit change.', detailed_explanation: "You get a clear summary of the trade-off. For example: 'Reducing discounts by 10% is projected to decrease sales volume by 4%, but increase gross profit by $15,000 per month due to higher margins.'" },
            { id: 's6_monitor', label: 'Track & Refine', type: 'monitor', short_hint: 'Monitor actual results post-change to improve the model.', detailed_explanation: "If the discount change is implemented, the system can track the actual impact on both sales volume and profit margins, comparing it against the simulation's predictions to refine future analyses." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
        downloadables: ['discount_simulation.pdf'],
    },
  },
  {
    id: 'simulate_ad_spend_increase',
    category: 'Simulation',
    title: 'What happens if ad spend is increased next month?',
    workflow: {
        step1: "The system understands you're considering increasing your advertising budget and want to predict the likely return on that investment in terms of traffic and revenue.",
        step2: "This calls for a Hybrid (SQL → Python) path. SQL will retrieve past marketing performance data, and Python will model the relationship between spend and outcomes.",
        step3: "The SQL agent pulls historical data from your marketing platforms. This includes ad spend per channel, impressions, clicks, and the resulting conversions or revenue.",
        step4: "The Python agent builds a marketing mix model. It determines the historical Return on Ad Spend (ROAS) for each channel and models the curve of diminishing returns (i.e., the first $1,000 spent has more impact than the tenth $1,000). It then projects the additional revenue from an increased budget.",
        step5: "You receive a forecast and a recommendation. For example: 'Increasing ad spend by $20,000 next month is projected to generate an additional $65,000 in revenue. We recommend allocating 60% of the increase to 'Paid Search' and 40% to 'Social Ads' for optimal ROAS.'",
        step6: "After increasing the ad spend, the system tracks the actual performance against the forecast. This real-world data is used to continually refine the marketing mix model, making future simulations more accurate.",
    },
    flowchartSpec: {
        title: 'What Happens if Ad Spend is Increased Next Month?',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Predict the revenue impact of a higher ad budget.', detailed_explanation: "The system understands you're considering increasing your advertising budget and want to predict the likely return on that investment in terms of traffic and revenue." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path to model marketing effectiveness.', detailed_explanation: "This calls for a Hybrid (SQL → Python) path. SQL will retrieve past marketing performance data, and Python will model the relationship between spend and outcomes." },
            { id: 's3_sql', label: 'SQL Agent: Get Marketing Data', type: 'sql', short_hint: 'Pull historical ad spend, clicks, and revenue.', detailed_explanation: "The SQL agent pulls historical data from your marketing platforms. This includes ad spend per channel, impressions, clicks, and the resulting conversions or revenue." },
            { id: 's4_python', label: 'Python Agent: Model ROAS', type: 'python', short_hint: 'Model return on ad spend and diminishing returns.', detailed_explanation: "The Python agent builds a marketing mix model. It determines the historical Return on Ad Spend (ROAS) for each channel and models the curve of diminishing returns (i.e., the first $1,000 spent has more impact than the tenth $1,000). It then projects the additional revenue from an increased budget." },
            { id: 's5_output', label: 'Final Output: Revenue Forecast', type: 'output', short_hint: 'Provide a projection and budget allocation advice.', detailed_explanation: "You receive a forecast and a recommendation. For example: 'Increasing ad spend by $20,000 next month is projected to generate an additional $65,000 in revenue. We recommend allocating 60% of the increase to 'Paid Search' and 40% to 'Social Ads' for optimal ROAS.'" },
            { id: 's6_monitor', label: 'Track Performance & Refine', type: 'monitor', short_hint: 'Compare actuals to forecast and update the model.', detailed_explanation: "After increasing the ad spend, the system tracks the actual performance against the forecast. This real-world data is used to continually refine the marketing mix model, making future simulations more accurate." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
        downloadables: ['ad_spend_simulation.pdf'],
    },
  },
    {
    id: 'simulate_stockout',
    category: 'Simulation',
    title: 'What if a top-selling product goes out of stock?',
    workflow: {
        step1: "The system understands you want to quantify the risk of a top-selling product going out of stock. The goal is to estimate the direct lost revenue and potential secondary effects, like customers buying an alternative.",
        step2: "A Hybrid (SQL → Python) path is best. SQL will get the product's sales data and customer buying patterns. Python will simulate the financial impact of the stockout.",
        step3: "The SQL agent pulls the average daily sales volume for the top-selling product. It also analyzes shopping baskets to see what other products are frequently bought alongside it.",
        step4: "The Python agent simulates a stockout for a given number of days. It calculates the direct lost revenue based on average sales. It can also estimate secondary revenue loss from associated products that won't be purchased, and potential substitution effects where a customer might buy a different item instead.",
        step5: "You get a clear impact assessment: 'A 7-day stockout of 'Product A' is projected to cause $45,000 in direct lost revenue. We also estimate a 10% chance customers will substitute with 'Product B', and a potential secondary loss of $8,000 from companion products.'",
        step6: "The system can use this simulation to set dynamic safety stock levels. For critical, top-selling products, it can recommend holding more inventory to minimize the risk and financial impact of a potential stockout.",
    },
    flowchartSpec: {
        title: 'What if a Top-Selling Product Goes Out of Stock?',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Estimate the revenue loss from a stockout.', detailed_explanation: "The system understands you want to quantify the risk of a top-selling product going out of stock. The goal is to estimate the direct lost revenue and potential secondary effects, like customers buying an alternative." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path to get sales data and model the impact.', detailed_explanation: "A Hybrid (SQL → Python) path is best. SQL will get the product's sales data and customer buying patterns. Python will simulate the financial impact of the stockout." },
            { id: 's3_sql', label: 'SQL Agent: Get Sales & Basket Data', type: 'sql', short_hint: 'Pull sales velocity and companion products.', detailed_explanation: "The SQL agent pulls the average daily sales volume for the top-selling product. It also analyzes shopping baskets to see what other products are frequently bought alongside it." },
            { id: 's4_python', label: 'Python Agent: Simulate Stockout Impact', type: 'python', short_hint: 'Calculate direct and secondary revenue loss.', detailed_explanation: "The Python agent simulates a stockout for a given number of days. It calculates the direct lost revenue based on average sales. It can also estimate secondary revenue loss from associated products that won't be purchased, and potential substitution effects where a customer might buy a different item instead." },
            { id: 's5_output', label: 'Final Output: Impact Assessment', type: 'output', short_hint: 'Provide a clear estimate of financial losses.', detailed_explanation: "You get a clear impact assessment: 'A 7-day stockout of 'Product A' is projected to cause $45,000 in direct lost revenue. We also estimate a 10% chance customers will substitute with 'Product B', and a potential secondary loss of $8,000 from companion products.'" },
            { id: 's6_monitor', label: 'Inform Safety Stock Levels', type: 'monitor', short_hint: 'Use simulation results to optimize inventory.', detailed_explanation: "The system can use this simulation to set dynamic safety stock levels. For critical, top-selling products, it can recommend holding more inventory to minimize the risk and financial impact of a potential stockout." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
    },
  },
  {
    id: 'simulate_shipping_delay',
    category: 'Simulation',
    title: 'How much revenue do we lose if shipping gets delayed?',
    workflow: {
        step1: "The system understands you want to quantify the financial impact of shipping delays. This includes not just immediate cancellations, but also the long-term effect on customer loyalty and repeat purchases.",
        step2: "A Hybrid (SQL → Python) path is required. SQL will gather data on past orders and their delivery times. Python will model the relationship between delays and customer behavior.",
        step3: "The SQL agent pulls historical order data, noting the promised delivery date versus the actual delivery date. It also flags which of these customers made a repeat purchase within a certain timeframe (e.g., 90 days).",
        step4: "The Python agent analyzes this data to find a correlation between the length of a shipping delay and the probability of a customer churning (not buying again). It then simulates the impact of a potential future delay (e.g., an average 3-day delay) on long-term revenue.",
        step5: "You get a simulation result that quantifies the long-term cost. For example: 'A systemic 3-day shipping delay across all orders for one month is projected to reduce the repeat purchase rate by 5%, leading to an estimated long-term revenue loss of $120,000 over the next year.'",
        step6: "The system can continuously monitor shipping performance from carriers. If average delivery times start to slip, it can trigger an alert, allowing the operations team to address the issue before it significantly impacts customer retention.",
    },
    flowchartSpec: {
        title: 'How Much Revenue is Lost if Shipping Gets Delayed?',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Quantify the financial impact of shipping delays.', detailed_explanation: "The system understands you want to quantify the financial impact of shipping delays. This includes not just immediate cancellations, but also the long-term effect on customer loyalty and repeat purchases." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path to model the impact on customer loyalty.', detailed_explanation: "A Hybrid (SQL → Python) path is required. SQL will gather data on past orders and their delivery times. Python will model the relationship between delays and customer behavior." },
            { id: 's3_sql', label: 'SQL Agent: Get Order & Delivery Data', type: 'sql', short_hint: 'Pull historical delivery times and repeat purchases.', detailed_explanation: "The SQL agent pulls historical order data, noting the promised delivery date versus the actual delivery date. It also flags which of these customers made a repeat purchase within a certain timeframe (e.g., 90 days)." },
            { id: 's4_python', label: 'Python Agent: Model Churn Impact', type: 'python', short_hint: 'Correlate delays with the probability of churn.', detailed_explanation: "The Python agent analyzes this data to find a correlation between the length of a shipping delay and the probability of a customer churning (not buying again). It then simulates the impact of a potential future delay (e.g., an average 3-day delay) on long-term revenue." },
            { id: 's5_output', label: 'Final Output: Long-Term Revenue Loss', type: 'output', short_hint: 'Estimate the total financial cost of delays.', detailed_explanation: "You get a simulation result that quantifies the long-term cost. For example: 'A systemic 3-day shipping delay across all orders for one month is projected to reduce the repeat purchase rate by 5%, leading to an estimated long-term revenue loss of $120,000 over the next year.'" },
            { id: 's6_monitor', label: 'Monitor Shipping Performance', type: 'monitor', short_hint: 'Alert on slipping delivery times from carriers.', detailed_explanation: "The system can continuously monitor shipping performance from carriers. If average delivery times start to slip, it can trigger an alert, allowing the operations team to address the issue before it significantly impacts customer retention." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
    },
  },

  // D. Customer & Behavioral Use Cases
  {
    id: 'cluster_customers_by_behavior',
    category: 'Customer & Behavioral',
    title: 'Cluster customers based on behavior',
    workflow: {
        step1: "The system understands you want to group your customers into distinct segments based on how they shop, not just their demographics. This is for more effective marketing and personalization.",
        step2: "A Hybrid (SQL → Python) path is ideal. SQL will build a feature set for each customer, and Python will run clustering algorithms to find the natural groupings.",
        step3: "The SQL agent queries the database to create a behavioral profile for every customer. This includes metrics like purchase frequency, average order value, product categories purchased, and time of day they typically shop.",
        step4: "The Python agent takes these profiles and uses a suitable clustering method (like K-Means) to group similar customers together. It identifies distinct personas based on the data.",
        step5: "You receive a breakdown of your customer base into several key personas. For example: 'Cluster 1: 'Loyal High-Spenders' (frequent, high-value purchases). Cluster 2: 'Bargain Hunters' (shop only during sales). Cluster 3: 'One-Time Buyers' (have not returned after first purchase).'",
        step6: "The system can periodically re-run the clustering analysis to see how segments evolve over time. New customers are automatically assigned to a cluster, and existing customers can move between segments as their behavior changes.",
    },
    flowchartSpec: {
        title: 'Cluster Customers Based on Behavior',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Group customers into meaningful segments.', detailed_explanation: "The system understands you want to group your customers into distinct segments based on how they shop, not just their demographics. This is for more effective marketing and personalization." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path for feature engineering and clustering.', detailed_explanation: "A Hybrid (SQL → Python) path is ideal. SQL will build a feature set for each customer, and Python will run clustering algorithms to find the natural groupings." },
            { id: 's3_sql', label: 'SQL Agent: Build Customer Profiles', type: 'sql', short_hint: 'Create a behavioral profile for each customer.', detailed_explanation: "The SQL agent queries the database to create a behavioral profile for every customer. This includes metrics like purchase frequency, average order value, product categories purchased, and time of day they typically shop." },
            { id: 's4_python', label: 'Python Agent: Run Clustering Algorithm', type: 'python', short_hint: 'Group similar customers into personas.', detailed_explanation: "The Python agent takes these profiles and uses a suitable clustering method (like K-Means) to group similar customers together. It identifies distinct personas based on the data." },
            { id: 's5_output', label: 'Final Output: Customer Personas', type: 'output', short_hint: 'Deliver a breakdown of key customer segments.', detailed_explanation: "You receive a breakdown of your customer base into several key personas. For example: 'Cluster 1: 'Loyal High-Spenders' (frequent, high-value purchases). Cluster 2: 'Bargain Hunters' (shop only during sales). Cluster 3: 'One-Time Buyers' (have not returned after first purchase).'" },
            { id: 's6_monitor', label: 'Dynamic Segmentation', type: 'monitor', short_hint: 'Periodically refresh clusters and track movement.', detailed_explanation: "The system can periodically re-run the clustering analysis to see how segments evolve over time. New customers are automatically assigned to a cluster, and existing customers can move between segments as their behavior changes." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
        downloadables: ['customer_segments.csv', 'segmentation_report.pdf'],
    },
  },
  {
    id: 'analyze_product_buying_patterns',
    category: 'Customer & Behavioral',
    title: 'Analyze product buying patterns',
    workflow: {
        step1: "The system understands you want to uncover which products are frequently purchased together. This is also known as market basket analysis and is key for product recommendations, bundling, and store layout.",
        step2: "A Hybrid (SQL → Python) path is the standard for this. SQL will prepare the list of transactions, and Python will run the pattern mining algorithms.",
        step3: "The SQL agent pulls a list of all transactions, with each transaction containing a list of the products purchased. This is the raw material for the analysis.",
        step4: "The Python agent uses an association rule mining algorithm (like Apriori) to find statistically significant relationships. It looks for rules like 'If a customer buys Product A, they are 80% likely to also buy Product B.'",
        step5: "You receive a list of the strongest product associations. For example: 'Customers who buy coffee beans also frequently buy milk filters.' or 'Laptops and laptop stands are purchased together in 60% of laptop transactions.' These insights can be used to create 'Frequently Bought Together' sections.",
        step6: "This analysis can be run periodically (e.g., monthly) to detect new or changing buying patterns as new products are introduced or as seasons change. The recommendations can be automatically updated based on the latest results.",
    },
    flowchartSpec: {
        title: 'Analyze Product Buying Patterns',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Find which products are bought together.', detailed_explanation: "The system understands you want to uncover which products are frequently purchased together. This is also known as market basket analysis and is key for product recommendations, bundling, and store layout." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path for transaction data and pattern mining.', detailed_explanation: "A Hybrid (SQL → Python) path is the standard for this. SQL will prepare the list of transactions, and Python will run the pattern mining algorithms." },
            { id: 's3_sql', label: 'SQL Agent: Get Transaction Data', type: 'sql', short_hint: 'Pull a list of products in each order.', detailed_explanation: "The SQL agent pulls a list of all transactions, with each transaction containing a list of the products purchased. This is the raw material for the analysis." },
            { id: 's4_python', label: 'Python Agent: Mine Association Rules', type: 'python', short_hint: 'Find statistically significant product pairings.', detailed_explanation: "The Python agent uses an association rule mining algorithm (like Apriori) to find statistically significant relationships. It looks for rules like 'If a customer buys Product A, they are 80% likely to also buy Product B.'" },
            { id: 's5_output', label: 'Final Output: Strongest Associations', type: 'output', short_hint: 'Provide a list of product pairing insights.', detailed_explanation: "You receive a list of the strongest product associations. For example: 'Customers who buy coffee beans also frequently buy milk filters.' or 'Laptops and laptop stands are purchased together in 60% of laptop transactions.' These insights can be used to create 'Frequently Bought Together' sections." },
            { id: 's6_monitor', label: 'Periodic Pattern Refresh', type: 'monitor', short_hint: 'Re-run analysis to find new and changing trends.', detailed_explanation: "This analysis can be run periodically (e.g., monthly) to detect new or changing buying patterns as new products are introduced or as seasons change. The recommendations can be automatically updated based on the latest results." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
        downloadables: ['product_associations.csv'],
    },
  },
   {
    id: 'segment_by_discount_sensitivity',
    category: 'Customer & Behavioral',
    title: 'Find customer segments based on discount sensitivity',
    workflow: {
        step1: "The system understands you want to know which of your customers only buy with a discount versus those who are willing to pay full price. This helps in optimizing promotion targeting and maximizing profit.",
        step2: "A Hybrid (SQL → Python) path is perfect. SQL will calculate each customer's discount usage, and Python will segment them.",
        step3: "For each customer, the SQL agent calculates a 'discount ratio': the percentage of their total spending that was made using a discount code or on a sale item.",
        step4: "The Python agent takes these discount ratios and clusters the customers. It identifies distinct groups, such as 'Full-Price Buyers' (0-10% discount ratio), 'Occasional Deal Seekers' (30-50%), and 'Discount-Reliant Shoppers' (80%+).",
        step5: "You receive a report showing the size of each segment and their value to the business. For instance, you might find that the 'Full-Price Buyers' make up only 20% of your customers but generate 50% of your profit.",
        step6: "These segments can be dynamically updated. When planning a new promotional campaign, you can choose to exclude the 'Full-Price Buyers' segment to avoid giving away margin unnecessarily, targeting the offer to those who are more influenced by discounts.",
    },
    flowchartSpec: {
        title: 'Find Customer Segments Based on Discount Sensitivity',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Group customers by how much they rely on discounts.', detailed_explanation: "The system understands you want to know which of your customers only buy with a discount versus those who are willing to pay full price. This helps in optimizing promotion targeting and maximizing profit." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path to calculate ratios and create segments.', detailed_explanation: "A Hybrid (SQL → Python) path is perfect. SQL will calculate each customer's discount usage, and Python will segment them." },
            { id: 's3_sql', label: 'SQL Agent: Calculate Discount Ratios', type: 'sql', short_hint: 'For each customer, find the % of spending on discount.', detailed_explanation: "For each customer, the SQL agent calculates a 'discount ratio': the percentage of their total spending that was made using a discount code or on a sale item." },
            { id: 's4_python', label: 'Python Agent: Segment Customers', type: 'python', short_hint: 'Cluster customers based on their discount ratio.', detailed_explanation: "The Python agent takes these discount ratios and clusters the customers. It identifies distinct groups, such as 'Full-Price Buyers' (0-10% discount ratio), 'Occasional Deal Seekers' (30-50%), and 'Discount-Reliant Shoppers' (80%+)." },
            { id: 's5_output', label: 'Final Output: Discount Sensitivity Segments', type: 'output', short_hint: 'Provide a breakdown of the segments and their value.', detailed_explanation: "You receive a report showing the size of each segment and their value to the business. For instance, you might find that the 'Full-Price Buyers' make up only 20% of your customers but generate 50% of your profit." },
            { id: 's6_monitor', label: 'Dynamic Promotion Targeting', type: 'monitor', short_hint: 'Use segments to optimize who receives offers.', detailed_explanation: "These segments can be dynamically updated. When planning a new promotional campaign, you can choose to exclude the 'Full-Price Buyers' segment to avoid giving away margin unnecessarily, targeting the offer to those who are more influenced by discounts." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
        downloadables: ['discount_segments.csv'],
    },
  },
  {
    id: 'segment_by_purchase_seasonality',
    category: 'Customer & Behavioral',
    title: 'Segment customers based on purchase seasonality',
    workflow: {
        step1: "The system understands you want to identify customers who have strong seasonal buying patterns, like 'Holiday Shoppers' or 'Summer Buyers'. This allows for timely and relevant marketing campaigns.",
        step2: "A Hybrid (SQL → Python) path is effective. SQL will aggregate each customer's purchases by month or season, and Python will identify the dominant seasonal pattern.",
        step3: "The SQL agent processes the entire purchase history and, for each customer, creates a summary of their spending in each month of the year (e.g., 60% of spending in November/December).",
        step4: "The Python agent analyzes these monthly spending distributions. It clusters customers with similar patterns, identifying groups like 'Year-Round Shoppers', 'Back-to-School Buyers', 'Holiday Gifters', etc.",
        step5: "You get a set of seasonal personas with descriptions. For example: 'Holiday Shoppers (15% of customers): Make over 50% of their annual purchases in Q4. Highly responsive to Black Friday deals.'",
        step6: "These segments can be used to plan your marketing calendar. You can schedule targeted email campaigns to 'Summer Buyers' in May, and start engaging 'Holiday Shoppers' in October, making your marketing more efficient and effective.",
    },
    flowchartSpec: {
        title: 'Segment Customers Based on Purchase Seasonality',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Find customers with seasonal buying habits.', detailed_explanation: "The system understands you want to identify customers who have strong seasonal buying patterns, like 'Holiday Shoppers' or 'Summer Buyers'. This allows for timely and relevant marketing campaigns." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path to analyze spending patterns over time.', detailed_explanation: "A Hybrid (SQL → Python) path is effective. SQL will aggregate each customer's purchases by month or season, and Python will identify the dominant seasonal pattern." },
            { id: 's3_sql', label: 'SQL Agent: Aggregate Monthly Spending', type: 'sql', short_hint: 'Summarize each customer\'s spending by month.', detailed_explanation: "The SQL agent processes the entire purchase history and, for each customer, creates a summary of their spending in each month of the year (e.g., 60% of spending in November/December)." },
            { id: 's4_python', label: 'Python Agent: Identify Seasonal Clusters', type: 'python', short_hint: 'Group customers with similar seasonal patterns.', detailed_explanation: "The Python agent analyzes these monthly spending distributions. It clusters customers with similar patterns, identifying groups like 'Year-Round Shoppers', 'Back-to-School Buyers', 'Holiday Gifters', etc." },
            { id: 's5_output', label: 'Final Output: Seasonal Personas', type: 'output', short_hint: 'Deliver a breakdown of seasonal customer groups.', detailed_explanation: "You get a set of seasonal personas with descriptions. For example: 'Holiday Shoppers (15% of customers): Make over 50% of their annual purchases in Q4. Highly responsive to Black Friday deals.'" },
            { id: 's6_monitor', label: 'Inform Marketing Calendar', type: 'monitor', short_hint: 'Use segments to time campaigns effectively.', detailed_explanation: "These segments can be used to plan your marketing calendar. You can schedule targeted email campaigns to 'Summer Buyers' in May, and start engaging 'Holiday Shoppers' in October, making your marketing more efficient and effective." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
    },
  },
   {
    id: 'identify_high_low_value_customers',
    category: 'Customer & Behavioral',
    title: 'Identify high-value vs low-value customers',
    workflow: {
        step1: "The system understands you want a straightforward way to separate your best customers from the rest. The goal is to focus retention efforts on the most valuable group and find strategies to grow the low-value group.",
        step2: "A Hybrid (SQL → Python) path is best. SQL will calculate key metrics for each customer, and Python will use these to create the segments.",
        step3: "The SQL agent calculates three simple but powerful metrics for each customer: Recency (how recently they bought), Frequency (how often they buy), and Monetary Value (how much they spend). This is known as RFM analysis.",
        step4: "The Python agent takes the RFM scores for all customers and segments them into tiers. It identifies groups like 'Champions' (high on all three), 'At-Risk Customers' (high value but haven't bought recently), and 'New Customers'.",
        step5: "You receive a clear dashboard showing the size and total value of each RFM segment. This clearly highlights who your most valuable customers are and provides a list of customers in each category for targeted actions.",
        step6: "The system can track how customers move between these segments over time. For example, it can alert you if a 'Champion' customer becomes 'At-Risk', giving you a chance to re-engage them with a special offer before they are lost.",
    },
    flowchartSpec: {
        title: 'Identify High-Value vs Low-Value Customers',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Segment customers based on their value.', detailed_explanation: "The system understands you want a straightforward way to separate your best customers from the rest. The goal is to focus retention efforts on the most valuable group and find strategies to grow the low-value group." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path for RFM analysis and segmentation.', detailed_explanation: "A Hybrid (SQL → Python) path is best. SQL will calculate key metrics for each customer, and Python will use these to create the segments." },
            { id: 's3_sql', label: 'SQL Agent: Calculate RFM Scores', type: 'sql', short_hint: 'Get Recency, Frequency, and Monetary data.', detailed_explanation: "The SQL agent calculates three simple but powerful metrics for each customer: Recency (how recently they bought), Frequency (how often they buy), and Monetary Value (how much they spend). This is known as RFM analysis." },
            { id: 's4_python', label: 'Python Agent: Create RFM Segments', type: 'python', short_hint: 'Group customers into value-based tiers.', detailed_explanation: "The Python agent takes the RFM scores for all customers and segments them into tiers. It identifies groups like 'Champions' (high on all three), 'At-Risk Customers' (high value but haven't bought recently), and 'New Customers'." },
            { id: 's5_output', label: 'Final Output: Value Segments Dashboard', type: 'output', short_hint: 'Visualize the breakdown of customer value tiers.', detailed_explanation: "You receive a clear dashboard showing the size and total value of each RFM segment. This clearly highlights who your most valuable customers are and provides a list of customers in each category for targeted actions." },
            { id: 's6_monitor', label: 'Track Segment Migration', type: 'monitor', short_hint: 'Monitor customer movement between value tiers.', detailed_explanation: "The system can track how customers move between these segments over time. For example, it can alert you if a 'Champion' customer becomes 'At-Risk', giving you a chance to re-engage them with a special offer before they are lost." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
        downloadables: ['customer_rfm_segments.csv'],
    },
  },

  // E. Product & Operational Use Cases
  {
    id: 'recommend_growth_products',
    category: 'Product & Operational',
    title: 'Recommend products likely to grow in next quarter',
    workflow: {
        step1: "The system understands you want to identify 'rising star' products that have strong growth potential, so you can focus marketing and inventory on them.",
        step2: "A Hybrid (SQL → Python) path is best. SQL will extract sales trends, and Python will analyze momentum to make recommendations.",
        step3: "The SQL agent pulls the week-over-week or month-over-month sales growth rate for every product over the last six months.",
        step4: "The Python agent analyzes these growth trajectories. It looks for products with accelerating sales growth that aren't yet top-sellers. It prioritizes products that are gaining momentum consistently.",
        step5: "You get a curated list of 'Products to Watch'. For each product, it shows the recent growth rate and projects its potential sales volume in the next quarter if the trend continues.",
        step6: "The system can add these 'Products to Watch' to a dedicated dashboard that tracks their sales performance weekly, confirming if they are meeting their growth potential and helping you decide when to increase marketing support.",
    },
    flowchartSpec: {
        title: 'Recommend Products Likely to Grow in Next Quarter',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Identify "rising star" products.', detailed_explanation: "The system understands you want to identify 'rising star' products that have strong growth potential, so you can focus marketing and inventory on them." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path to analyze sales momentum.', detailed_explanation: "A Hybrid (SQL → Python) path is best. SQL will extract sales trends, and Python will analyze momentum to make recommendations." },
            { id: 's3_sql', label: 'SQL Agent: Get Sales Growth Rates', type: 'sql', short_hint: 'Pull month-over-month growth for each product.', detailed_explanation: "The SQL agent pulls the week-over-week or month-over-month sales growth rate for every product over the last six months." },
            { id: 's4_python', label: 'Python Agent: Identify Momentum', type: 'python', short_hint: 'Find products with accelerating growth.', detailed_explanation: "The Python agent analyzes these growth trajectories. It looks for products with accelerating sales growth that aren't yet top-sellers. It prioritizes products that are gaining momentum consistently." },
            { id: 's5_output', label: 'Final Output: "Products to Watch" List', type: 'output', short_hint: 'Provide a list of high-potential products.', detailed_explanation: "You get a curated list of 'Products to Watch'. For each product, it shows the recent growth rate and projects its potential sales volume in the next quarter if the trend continues." },
            { id: 's6_monitor', label: 'Growth Tracking Dashboard', type: 'monitor', short_hint: 'Monitor the performance of recommended products.', detailed_explanation: "The system can add these 'Products to Watch' to a dedicated dashboard that tracks their sales performance weekly, confirming if they are meeting their growth potential and helping you decide when to increase marketing support." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
    },
  },
  {
    id: 'detect_categories_losing_momentum',
    category: 'Product & Operational',
    title: 'Detect categories losing momentum',
    workflow: {
        step1: "The system understands you need to identify product categories that are declining in sales or relevance. This helps in making decisions about inventory, marketing focus, or discontinuing product lines.",
        step2: "A Hybrid (SQL → Python) path is suitable. SQL will aggregate sales data at the category level, and Python will analyze long-term trends.",
        step3: "The SQL agent groups all product sales into their respective categories and calculates the month-over-month and year-over-year sales growth for each category.",
        step4: "The Python agent analyzes these trends over a longer period (e.g., two years). It looks for categories with sustained negative growth or deceleration, separating a temporary dip from a long-term decline.",
        step5: "You receive a report highlighting 'Declining Categories'. For each one, it shows a chart of its historical sales trend and its year-over-year performance, making the decline clear.",
        step6: "The system can set up alerts for any product category that shows a consistent decline for a set period (e.g., three consecutive months of negative year-over-year growth), prompting a strategic review.",
    },
    flowchartSpec: {
        title: 'Detect Categories Losing Momentum',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Find product categories in long-term decline.', detailed_explanation: "The system understands you need to identify product categories that are declining in sales or relevance. This helps in making decisions about inventory, marketing focus, or discontinuing product lines." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path to analyze category-level trends.', detailed_explanation: "A Hybrid (SQL → Python) path is suitable. SQL will aggregate sales data at the category level, and Python will analyze long-term trends." },
            { id: 's3_sql', label: 'SQL Agent: Aggregate Category Sales', type: 'sql', short_hint: 'Calculate MoM and YoY growth per category.', detailed_explanation: "The SQL agent groups all product sales into their respective categories and calculates the month-over-month and year-over-year sales growth for each category." },
            { id: 's4_python', label: 'Python Agent: Analyze Long-Term Trends', type: 'python', short_hint: 'Identify sustained deceleration or decline.', detailed_explanation: "The Python agent analyzes these trends over a longer period (e.g., two years). It looks for categories with sustained negative growth or deceleration, separating a temporary dip from a long-term decline." },
            { id: 's5_output', label: 'Final Output: Declining Categories Report', type: 'output', short_hint: 'Highlight categories with falling sales.', detailed_explanation: "You receive a report highlighting 'Declining Categories'. For each one, it shows a chart of its historical sales trend and its year-over-year performance, making the decline clear." },
            { id: 's6_monitor', label: 'Decline Monitoring Alerts', type: 'monitor', short_hint: 'Alert on sustained negative category growth.', detailed_explanation: "The system can set up alerts for any product category that shows a consistent decline for a set period (e.g., three consecutive months of negative year-over-year growth), prompting a strategic review." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
    },
  },
   {
    id: 'find_products_affected_by_competitors',
    category: 'Product & Operational',
    title: 'Find products affected by competitor price changes',
    workflow: {
        step1: "The system understands you want to know if a competitor's recent price drop is hurting the sales of your own products. The goal is to identify which of your products are most vulnerable to competitor pricing.",
        step2: "This requires a Hybrid (SQL → Python) approach, and assumes access to competitor pricing data (e.g., from a web-scraping service). SQL will align your sales data with the competitor data, and Python will find the correlation.",
        step3: "The SQL agent takes the competitor's pricing data over time and aligns it with your own product sales data on a daily or weekly timeline. It focuses on directly comparable products.",
        step4: "The Python agent looks for a negative correlation: when the competitor's price for a specific item goes down, do your sales for the equivalent item also go down? It calculates how sensitive your sales are to their price changes.",
        step5: "You get a 'Competitor Sensitivity Report'. It lists your products that are most impacted by competitor pricing, showing how much your sales typically drop for every 1% decrease in their price. For example: 'Our 'Pro Blender X' sales drop by an average of 3% for every 5% price drop on their 'BlendMax 5000'.",
        step6: "The system can monitor competitor price feeds in near real-time. If a key competitor drops the price on a sensitive item, it can send an alert, allowing you to quickly decide whether to match the price or launch a counter-promotion.",
    },
    flowchartSpec: {
        title: 'Find Products Affected by Competitor Price Changes',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: See if competitor prices are hurting sales.', detailed_explanation: "The system understands you want to know if a competitor's recent price drop is hurting the sales of your own products. The goal is to identify which of your products are most vulnerable to competitor pricing." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path to correlate sales and competitor data.', detailed_explanation: "This requires a Hybrid (SQL → Python) approach, and assumes access to competitor pricing data (e.g., from a web-scraping service). SQL will align your sales data with the competitor data, and Python will find the correlation." },
            { id: 's3_sql', label: 'SQL Agent: Align Sales & Pricing Data', type: 'sql', short_hint: 'Match your sales data with competitor price history.', detailed_explanation: "The SQL agent takes the competitor's pricing data over time and aligns it with your own product sales data on a daily or weekly timeline. It focuses on directly comparable products." },
            { id: 's4_python', label: 'Python Agent: Correlate Sales & Price', type: 'python', short_hint: 'Find links between their price drops and your sales drops.', detailed_explanation: "The Python agent looks for a negative correlation: when the competitor's price for a specific item goes down, do your sales for the equivalent item also go down? It calculates how sensitive your sales are to their price changes." },
            { id: 's5_output', label: 'Final Output: Sensitivity Report', type: 'output', short_hint: 'List products most vulnerable to competitor pricing.', detailed_explanation: "You get a 'Competitor Sensitivity Report'. It lists your products that are most impacted by competitor pricing, showing how much your sales typically drop for every 1% decrease in their price. For example: 'Our 'Pro Blender X' sales drop by an average of 3% for every 5% price drop on their 'BlendMax 5000'." },
            { id: 's6_monitor', label: 'Real-time Price Monitoring', type: 'monitor', short_hint: 'Alert on competitor price drops for key items.', detailed_explanation: "The system can monitor competitor price feeds in near real-time. If a key competitor drops the price on a sensitive item, it can send an alert, allowing you to quickly decide whether to match the price or launch a counter-promotion." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
    },
  },
  {
    id: 'identify_supply_chain_bottlenecks',
    category: 'Product & Operational',
    title: 'Identify supply chain bottlenecks affecting sales',
    workflow: {
        step1: "The system understands you want to find out where the delays are in your supply chain—from ordering from a supplier to delivering to the customer—and how these delays impact sales.",
        step2: "A Hybrid (SQL → Python) path is needed to stitch together data from different stages. SQL will gather all the timestamped data, and Python will analyze the flow.",
        step3: "The SQL agent pulls data from multiple systems: supplier order dates, warehouse receiving dates, customer order dates, and final delivery dates. It pieces together the end-to-end timeline for orders.",
        step4: "The Python agent calculates the duration of each stage in the supply chain (e.g., 'Time at Warehouse', 'Time in Transit'). It identifies which stages are taking the longest or have the most variability, pinpointing the bottlenecks. It then correlates these delays with negative outcomes like order cancellations.",
        step5: "You get a supply chain performance dashboard. It visualizes the average time for each stage and highlights the biggest bottlenecks. For example: 'The average order spends 5 days in the 'Awaiting Shipment' stage at the warehouse, which is the main source of delays and is correlated with a 5% cancellation rate.'",
        step6: "The system can continuously monitor these stage durations. If the time spent in a specific stage (like 'Awaiting Shipment') starts to increase, it can trigger an alert to the operations team to investigate before it becomes a major problem.",
    },
    flowchartSpec: {
        title: 'Identify Supply Chain Bottlenecks Affecting Sales',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Find and measure delays in the supply chain.', detailed_explanation: "The system understands you want to find out where the delays are in your supply chain—from ordering from a supplier to delivering to the customer—and how these delays impact sales." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path to analyze end-to-end order timelines.', detailed_explanation: "A Hybrid (SQL → Python) path is needed to stitch together data from different stages. SQL will gather all the timestamped data, and Python will analyze the flow." },
            { id: 's3_sql', label: 'SQL Agent: Gather Timeline Data', type: 'sql', short_hint: 'Pull timestamps from order to delivery.', detailed_explanation: "The SQL agent pulls data from multiple systems: supplier order dates, warehouse receiving dates, customer order dates, and final delivery dates. It pieces together the end-to-end timeline for orders." },
            { id: 's4_python', label: 'Python Agent: Analyze Stage Durations', type: 'python', short_hint: 'Calculate time spent at each stage to find delays.', detailed_explanation: "The Python agent calculates the duration of each stage in the supply chain (e.g., 'Time at Warehouse', 'Time in Transit'). It identifies which stages are taking the longest or have the most variability, pinpointing the bottlenecks. It then correlates these delays with negative outcomes like order cancellations." },
            { id: 's5_output', label: 'Final Output: Bottleneck Report', type: 'output', short_hint: 'Visualize and pinpoint the biggest delays.', detailed_explanation: "You get a supply chain performance dashboard. It visualizes the average time for each stage and highlights the biggest bottlenecks. For example: 'The average order spends 5 days in the 'Awaiting Shipment' stage at the warehouse, which is the main source of delays and is correlated with a 5% cancellation rate.'" },
            { id: 's6_monitor', label: 'Continuous Monitoring', type: 'monitor', short_hint: 'Alert when delays in a specific stage increase.', detailed_explanation: "The system can continuously monitor these stage durations. If the time spent in a specific stage (like 'Awaiting Shipment') starts to increase, it can trigger an alert to the operations team to investigate before it becomes a major problem." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
    },
  },

  // F. Marketing Use Cases
  {
    id: 'find_top_marketing_channels',
    category: 'Marketing',
    title: 'Find which marketing channels drive the most conversions',
    workflow: {
        step1: "The system understands you want to know which of your marketing efforts (e.g., Google Ads, Facebook, email) are actually bringing in paying customers, so you can allocate your budget effectively.",
        step2: "A SQL-only path is often sufficient for this, as it's a direct attribution analysis. SQL can join traffic source data with conversion data.",
        step3: "The SQL agent queries your web analytics and sales data. It attributes each sale or conversion to the marketing channel that brought the user to the site (e.g., using UTM parameters). It then calculates the total conversions and conversion rate for each channel.",
        step4: "Python is not strictly necessary here, but could be used for more advanced attribution models (e.g., multi-touch attribution) if the user wants to go deeper.",
        step5: "You receive a clear, ranked table showing the performance of each marketing channel. It includes metrics like total conversions, conversion rate, and cost per acquisition (if ad spend data is available). For example: 'Email marketing drove the most conversions (850) with the highest conversion rate (5.2%).'",
        step6: "This report can be set up to run automatically on a weekly or monthly basis. You can monitor channel performance over time and quickly spot if a previously strong channel is starting to underperform.",
    },
    flowchartSpec: {
        title: 'Find Which Marketing Channels Drive Most Conversions',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Attribute conversions to marketing channels.', detailed_explanation: "The system understands you want to know which of your marketing efforts (e.g., Google Ads, Facebook, email) are actually bringing in paying customers, so you can allocate your budget effectively." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'SQL-only is often enough for direct attribution.', detailed_explanation: "A SQL-only path is often sufficient for this, as it's a direct attribution analysis. SQL can join traffic source data with conversion data." },
            { id: 's3_sql', label: 'SQL Agent: Attribute Conversions', type: 'sql', short_hint: 'Join traffic sources with sales data.', detailed_explanation: "The SQL agent queries your web analytics and sales data. It attributes each sale or conversion to the marketing channel that brought the user to the site (e.g., using UTM parameters). It then calculates the total conversions and conversion rate for each channel." },
            { id: 's4_python', label: 'Python Agent (Optional)', type: 'python', short_hint: 'Can be used for advanced attribution models.', detailed_explanation: "Python is not strictly necessary here, but could be used for more advanced attribution models (e.g., multi-touch attribution) if the user wants to go deeper." },
            { id: 's5_output', label: 'Final Output: Channel Performance Report', type: 'output', short_hint: 'Rank channels by conversions and conversion rate.', detailed_explanation: "You receive a clear, ranked table showing the performance of each marketing channel. It includes metrics like total conversions, conversion rate, and cost per acquisition (if ad spend data is available). For example: 'Email marketing drove the most conversions (850) with the highest conversion rate (5.2%).'" },
            { id: 's6_monitor', label: 'Automated Reporting', type: 'monitor', short_hint: 'Run the report weekly to track performance.', detailed_explanation: "This report can be set up to run automatically on a weekly or monthly basis. You can monitor channel performance over time and quickly spot if a previously strong channel is starting to underperform." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
        downloadables: ['channel_performance.csv'],
    },
  },
  {
    id: 'predict_campaign_performance',
    category: 'Marketing',
    title: 'Predict campaign performance for next month',
    workflow: {
        step1: "The system understands you're planning a new marketing campaign and want a forecast of its likely results (e.g., clicks, conversions, revenue) based on your budget and historical data.",
        step2: "A Hybrid (SQL → Python) path is required. SQL will gather data from past campaigns, and Python will build a predictive model.",
        step3: "The SQL agent pulls performance data from all similar past campaigns. This includes the budget, channels used, duration, and the resulting clicks and conversions.",
        step4: "The Python agent analyzes the relationship between campaign spend and performance. It builds a simple regression model to forecast the expected results for the planned new campaign based on its proposed budget.",
        step5: "You receive a clear forecast for your new campaign. For example: 'With a planned budget of $10,000, the 'Spring Sale' campaign is forecasted to generate between 15,000-18,000 clicks and 300-350 conversions.'",
        step6: "Once the campaign launches, the system can track its performance in real-time against the forecast. If it's over- or under-performing significantly after a few days, it can send an alert so you can make adjustments.",
    },
    flowchartSpec: {
        title: 'Predict Campaign Performance for Next Month',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Forecast the results of a planned campaign.', detailed_explanation: "The system understands you're planning a new marketing campaign and want a forecast of its likely results (e.g., clicks, conversions, revenue) based on your budget and historical data." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path to model past campaign data.', detailed_explanation: "A Hybrid (SQL → Python) path is required. SQL will gather data from past campaigns, and Python will build a predictive model." },
            { id: 's3_sql', label: 'SQL Agent: Get Past Campaign Data', type: 'sql', short_hint: 'Pull budget and performance of similar campaigns.', detailed_explanation: "The SQL agent pulls performance data from all similar past campaigns. This includes the budget, channels used, duration, and the resulting clicks and conversions." },
            { id: 's4_python', label: 'Python Agent: Build Predictive Model', type: 'python', short_hint: 'Forecast results based on the planned budget.', detailed_explanation: "The Python agent analyzes the relationship between campaign spend and performance. It builds a simple regression model to forecast the expected results for the planned new campaign based on its proposed budget." },
            { id: 's5_output', label: 'Final Output: Campaign Forecast', type: 'output', short_hint: 'Provide a projection of clicks and conversions.', detailed_explanation: "You receive a clear forecast for your new campaign. For example: 'With a planned budget of $10,000, the 'Spring Sale' campaign is forecasted to generate between 15,000-18,000 clicks and 300-350 conversions.'" },
            { id: 's6_monitor', label: 'Real-time Performance Tracking', type: 'monitor', short_hint: 'Track actual results against the forecast.', detailed_explanation: "Once the campaign launches, the system can track its performance in real-time against the forecast. If it's over- or under-performing significantly after a few days, it can send an alert so you can make adjustments." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
    },
  },
  {
    id: 'segment_by_marketing_engagement',
    category: 'Marketing',
    title: 'Segment customers by marketing engagement',
    workflow: {
        step1: "The system understands you want to group customers based on how they interact with your marketing, such as who opens emails versus who ignores them. This helps tailor communication strategies.",
        step2: "A Hybrid (SQL → Python) path is ideal. SQL will gather engagement data from various marketing tools, and Python will create the segments.",
        step3: "The SQL agent connects to your email marketing platform, ad platforms, and website analytics. For each customer, it pulls metrics like email open rate, click-through rate, and ad clicks.",
        step4: "The Python agent uses a clustering algorithm to group customers with similar engagement profiles. This will reveal natural segments like 'Email Subscribers' (high email engagement), 'Social Media Followers' (high ad clicks), and 'Unengaged'.",
        step5: "You get a report detailing the different engagement segments. For example: 'The 'Email Subscribers' segment is your most profitable, even though it's smaller than the 'Unengaged' segment. This suggests a need to re-engage the latter group via other channels.'",
        step6: "These segments can be synced back to your marketing tools. This allows you to send different messages to different groups; for example, a special offer to the 'Unengaged' segment to try and win them back, while sending regular content to your engaged subscribers.",
    },
    flowchartSpec: {
        title: 'Segment Customers by Marketing Engagement',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Group customers by how they interact with marketing.', detailed_explanation: "The system understands you want to group customers based on how they interact with your marketing, such as who opens emails versus who ignores them. This helps tailor communication strategies." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path to cluster on engagement data.', detailed_explanation: "A Hybrid (SQL → Python) path is ideal. SQL will gather engagement data from various marketing tools, and Python will create the segments." },
            { id: 's3_sql', label: 'SQL Agent: Gather Engagement Data', type: 'sql', short_hint: 'Pull email open/click rates and ad interactions.', detailed_explanation: "The SQL agent connects to your email marketing platform, ad platforms, and website analytics. For each customer, it pulls metrics like email open rate, click-through rate, and ad clicks." },
            { id: 's4_python', label: 'Python Agent: Create Engagement Segments', type: 'python', short_hint: 'Cluster customers into engagement personas.', detailed_explanation: "The Python agent uses a clustering algorithm to group customers with similar engagement profiles. This will reveal natural segments like 'Email Subscribers' (high email engagement), 'Social Media Followers' (high ad clicks), and 'Unengaged'." },
            { id: 's5_output', label: 'Final Output: Engagement Personas Report', type: 'output', short_hint: 'Deliver a breakdown of engagement-based groups.', detailed_explanation: "You get a report detailing the different engagement segments. For example: 'The 'Email Subscribers' segment is your most profitable, even though it's smaller than the 'Unengaged' segment. This suggests a need to re-engage the latter group via other channels.'" },
            { id: 's6_monitor', label: 'Sync Segments to Marketing Tools', type: 'monitor', short_hint: 'Use segments for targeted communication.', detailed_explanation: "These segments can be synced back to your marketing tools. This allows you to send different messages to different groups; for example, a special offer to the 'Unengaged' segment to try and win them back, while sending regular content to your engaged subscribers." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
    },
  },
  {
    id: 'detect_campaigns_causing_revenue_spikes',
    category: 'Marketing',
    title: 'Detect which campaigns caused revenue spikes or drops',
    workflow: {
        step1: "The system understands you want to connect specific marketing campaigns to significant changes in revenue. The goal is to identify your most impactful campaigns (both good and bad) to learn from them.",
        step2: "A Hybrid (SQL → Python) approach is needed. SQL will align campaign timelines with sales data, and Python will identify statistically significant correlations.",
        step3: "The SQL agent creates a master timeline. On this timeline, it plots daily revenue and overlays the start and end dates of every major marketing campaign.",
        step4: "The Python agent performs an event study analysis. For each campaign launch, it looks at the sales data immediately before, during, and after. It determines if there was a statistically significant increase or decrease in revenue that can be attributed to the campaign, filtering out random noise.",
        step5: "You receive a clear report of 'Impactful Campaigns'. For example: 'The 'Black Friday Email Blitz' campaign is correlated with a 40% lift in revenue during its 3-day run.' or 'The 'New Ad Creative Test' campaign coincided with a 10% drop in conversion rate for its target audience.'",
        step6: "The system can continuously monitor for these correlations in the background. As new campaigns are launched, it can automatically analyze their impact and add the findings to an ongoing campaign performance dashboard.",
    },
    flowchartSpec: {
        title: 'Detect Which Campaigns Caused Revenue Spikes or Drops',
        nodes: [
            { id: 's1_understand', label: 'Understand User Query', type: 'user', short_hint: 'Goal: Attribute revenue changes to specific campaigns.', detailed_explanation: "The system understands you want to connect specific marketing campaigns to significant changes in revenue. The goal is to identify your most impactful campaigns (both good and bad) to learn from them." },
            { id: 's2_path', label: 'Choose Execution Path', type: 'classifier', short_hint: 'Hybrid path for event study analysis.', detailed_explanation: "A Hybrid (SQL → Python) approach is needed. SQL will align campaign timelines with sales data, and Python will identify statistically significant correlations." },
            { id: 's3_sql', label: 'SQL Agent: Create Master Timeline', type: 'sql', short_hint: 'Align daily revenue with campaign start/end dates.', detailed_explanation: "The SQL agent creates a master timeline. On this timeline, it plots daily revenue and overlays the start and end dates of every major marketing campaign." },
            { id: 's4_python', label: 'Python Agent: Event Study Analysis', type: 'python', short_hint: 'Find significant revenue changes around campaign dates.', detailed_explanation: "The Python agent performs an event study analysis. For each campaign launch, it looks at the sales data immediately before, during, and after. It determines if there was a statistically significant increase or decrease in revenue that can be attributed to the campaign, filtering out random noise." },
            { id: 's5_output', label: 'Final Output: Impactful Campaigns Report', type: 'output', short_hint: 'List campaigns that caused significant revenue lifts or drops.', detailed_explanation: "You receive a clear report of 'Impactful Campaigns'. For example: 'The 'Black Friday Email Blitz' campaign is correlated with a 40% lift in revenue during its 3-day run.' or 'The 'New Ad Creative Test' campaign coincided with a 10% drop in conversion rate for its target audience.'" },
            { id: 's6_monitor', label: 'Continuous Impact Analysis', type: 'monitor', short_hint: 'Automatically analyze the impact of new campaigns.', detailed_explanation: "The system can continuously monitor for these correlations in the background. As new campaigns are launched, it can automatically analyze their impact and add the findings to an ongoing campaign performance dashboard." },
        ],
        edges: [
            { from: 's1_understand', to: 's2_path' }, { from: 's2_path', to: 's3_sql' }, { from: 's3_sql', to: 's4_python' }, { from: 's4_python', to: 's5_output' }, { from: 's5_output', to: 's6_monitor' },
        ],
        interaction_instructions: 'Click a node to see the detailed step explanation.',
    },
  },
];

export const useCaseCategories = [
  'Forecasting',
  'Diagnostic',
  'Simulation',
  'Customer & Behavioral',
  'Product & Operational',
  'Marketing'
];
